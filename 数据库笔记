#############################################################################################################################
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                               day1 RDBMS1
DB(DataBase)
数据库
DBMS()
数据库管理系统
DBS()
数据库系统即DB+DBMS

rm -f /etc/my.cinf
rm -rf /var/lib/mysql/*
rpm -e --nodeps mariadb-server mariadb.
安装数据库:#yum -y install mysql-community-*.rpm
          systemctl start mysqld
          systemctl enable mysqld
数据库存储在:/var/lib/mysql
数据库配置文件:/etc/my.cinf
查看进程:ps -C mysqld
查看端口:3306
错误日志文件:/var/log/mysqld.log
查看数据库密码并访问数据库服务: 
#grep password /var/log/mysqld.log
#mysql -hlocalhost -uroot -p'*Bc1hFVWWhnK'
查看软件版本:mysql> show variables like "%version%";
查看存储引擎的命令:mysql> show engines;
修改数据库密码:
mysql> alter user root@"localhost" identified by "123qqq...A";
设置默认长度和密码长度 
0 长度
1 or MEDIUM  长度 数字 大小写 特殊字符
2 or STRONG  长度 数字 大小写 特殊字符 字典文件
mysql> show variables like "%password%";
mysql>set global validate_password_policy=0; 
mysql>set global validate_password_length=6；
永久配置
[mysqld]
validate_password_policy=0
validate_password_length=6
修改数据库密码为:
mysql> alter user root@"localhost" identified by "tarena";
库管理命令:
      show databases;         显示库
      select user();          显示连接用户 
      use 库名;                     切换库
      select database();      显示当前所在的库
      create database 库名;      创建库
      show tables;            显示表
      drop database 库名;        删除库
创建库:库名 命名规则
   仅可以使用数字 字母 下划线 不能纯数字
   区分字母大小写 具有唯一性
   不可使用指令关键字 特殊字符
   例如:create database db1;
创建表:
create table 库名.表名(
   字段1 类型(宽度),
   字段2 类型(宽度),
)s;指定字符集
创建支持中文的表:create table 学生表2(姓名 char(10),年龄 int)DEFAULT CHARSET=utf8;
插入表数据:insert into 学生表2 values ("张三",88),("李四",70),("张翠山",30);
数据类型包括:
字符类型(char固定长度,最大存255个字符;varchar变长字符,65535个;大文本text/blob,图片/音频或视频)
数值类型(
整型正负 微小整型tinyint -128~127 小整形 smallint;
浮点型 单精度float 双精度double)
小数点整数5位,小数:create table t5 (name char(5),gz float(7,2));insert into t5 values("bob",99999.99);
日期时间型(日期时间datetime)datetime  timestamp  time  year  date
mysql> create table t7 (name char(5),your_start year,up_time time,birthday date,party datetime);
mysql> insert into t7 values ("bob",1990,083000,20191120,20190707213045);
mysql> insert into t7 values ("jerry",year(20190803),curtime(),curdate(),now());
mysql> insert into t7 values ("jerry",year(20190803),curtime(),curdate(),now());
枚举类型
enum 单选 只能选一个
set  多选 可以选多个
create table t10 (name char(10),sex enum("boy","girl","no"),likes set("eat","drink","game","happy"));
insert into t10 values ("bob","boy","eat,game");
select * from t10;

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#######################################################################################################################
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                         day2 Mysql的键值 表字段处理 
一、字段类型约束条件:
         null 允许为空
         not null 不允许为null
         key 键值类型
         default 设置默认值
         extra 额外设置
    键值类型:
         index  普通索引
         unique 唯一索引
         fulltext 全文索引
         primary key 主键
         oreign 外键
    索引类型:Btree、B+tree、hash

   例子:create table db2.t2 (name char(10) not null default "",age tinyint unsigned default 19,sex enum("m","w") not null default "m");
二、表字段处理的一些基本语法结构:
                 add 添加字段
                 modify 修改字段类型
                 change 修改字段名
                 drop 删除字段
                 rename 修改表名

   2.1.修改表结构:
       命令 alter table 库名.表名 执行动作;
     2.1.1.执行动作:
          添加新字段 add:
            末尾  add 字段名 类型
              alter table db2.t1 add email varchar(50);
            某字段列尾   add 字段名 类型 [约束条件] after 字段名;
              alter table db2.t1 add likes set("eat","drink","game","happy") not null default "eat,drink" after age;
            某字段列首   add 字段名 类型 [约束条件] first
              alter table db2.t1 add class char(7) default "nsd1905" first;
      2.1.2.修改字段类型 modify:
               修改字段位置:alter table db2.t1 modify age tinyint unsigned default 19 after class;
               修改字段类型:alter table db2.t1 modify name varchar(15) not null default "";
      2.1.3.修改字段名为mail使用的命令是change:
            alter table db2.t1 change email mail varchar(40);
      2.1.4.删除表字段drop:
            alter table db2.t1 drop mail;
      2.1.5.修改表名rename:
            alter table db2.t1 rename db2.stuinfo;

三、什么是索引:类似与书的目录,对表中的字段排序.索引占表物理空间,降低了数据的维护速度.好处是加快数据的查询速度.属于键值
    3.1.普通索引:使用规则(显示MUL)
      3.1.1.建表时创建索引  格式create table 库.表(字段列表,index(字段名),index(字段名));
                             例子create table db2.t2(name char(10),age int,class char(7),email char(30),index(name),index(age));
      3.1.2.在已有的表里创建索引  格式create index 索引名 on 表名(字段名);  
                                    例子create index name on db2.stuinfo(name);
      3.1.3查看索引字段:  基本查看desc 表明;key列显示索引    详细查看索引:show index from 表名 \G竖着查看
                           查看表结构desc db2.t2;          竖着查看show index from db2.t2 \G;     
      3.1.4.删除索引:  格式drop index 索引名 on 库.表名   例子drop index age on db2.t2; 
四、主    键:
    4.1 什么是主键:不能赋空值,主键值不能允许重复,就是表里数据不能重复.
       4.1.1 建表时创建主键:         
                   create table t3(name char(10) primary key,age int);或
                   create table t4(name char(10),age int,primary key(name));
                   insert into t4 values("",19)
                        insert into t3 values ()
       4.1.2 在已有表里创建主键:alter table 表名 add primary key(字段名);
                   alter table db2.stuinfo add primary key(name);
       4.1.3 创建复合主键多列一起做主键,是且关系,多列不能同时重复:create table db2.t5(class char(7),name char(10),money enum("no","yes"),primary key(class,name));
                   insert into db2.t5 values("nsd1905","bob","yes");
        4.1.4 删除主键:alter table db2.t5 drop primary key;
        4.1.5 删除一个表数据,然后新增字段,添加复合主键:
                    alter table db2.t5 add stu_num char(9) first;
                    delete from db2.t5;
                    select * from db2.t5;
                    show tables;
                    desc db2.t5;
                    alter table db2.t5 add prinary key(stu_num,class,name);
          4.1.6 主键与auto_increment(自增长)连用:字符必须是数值且是主键里的字段自加1.
                    create table db2.t6(stu_num int primary key auto_increment,name char(10),age int); 
                    desc db2.t6;     
           4.1.7 添加主键字段自加1:
             alter table db2.stuinfo add id int primary key auto_increment first; 
             添加表数据:insert into stuinfo(class,age,name,likes,sex) values("nsd1906",19,"bob","eat,drink","m");                   

                   insert into db2.t6 values(null,"mm",20);

五、外    键foreign key:
     5.1 什么是外键:向一个表插入记录时,字段值在另一个表字段值范围内选择.
      使用规则:
               表存储引擎必须是innodb
               字段类型要一致
               被参照字段必须要是索引类型的一种(primary key)
      建表时创建外键:create table 库.表 (字段列表,foreign key(字段名) references 库,表(字段名) on update cascade on delete cascade)engine=innodb;
     5.2 创建一个员工参照表并添加员工:
      create table db2.ygb(yg_id int primary key auto_increment,name char(20),sex enum("boy","girl"))engine=innodb;
      insert into db2.ygb(name,sex) values("bob","boy");
      insert into db2.ygb(name,sex) values("lucy","girl");
      select * from db2.ygb
      创建参照的工资表:
        create table gzb(gz_id int, pay float(7,2), foreign key(gz_id) references ygb(yg_id) on update cascade on delete cascade)engine=innodb;
      查看创建工资表的命令:show create table gzb;
      工资表添加工资:insert into gzb values(1,10000);
                 insert into gzb values(2,20000);
      同步更新表id为8:update ygb set yg_id=8 where yg_id=2;
                  select * from ygb;
                  select * from gzb;
      同步删除id为8:delete from ygb where yg_id=8;
                select * from ygb;
                select * from gzb;
      设置主键:alter table gzb add primary key(gz_id);
      删除外键:
               show create table gzb;                    查看此处gzb_ibfk_1有个外键标识
               alter table gzb drop foreign key gzb_ibfk_1;
               show create table gzb;                    在查看外键标识就没有了
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#######################################################################################################################
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                         day3 RDBMS1 数据管理
一、数据导入导出
    1.1.数据导入与导出默认检索路径
       1.1.1.查看
              数据库下面查看
              模糊查看:mysql> show variables like "%file%";
              精确查看:mysql> show variables like "sevure_file_priv";
              数据导入导出的目录,默认是空的:mysql> system ls /var/lib/mysql-files/
       1.1.2.修改数据库导入导出默认位置的配置文件
           #vim /etc/my.cnf
                [mysqld]
                secure_file_priv="/myload"
                :wq
           #mkdir /myload
           #chown mysql /myload
           #systemctl restart mysqld
           #mysql -uroot -ptarena
              精确查看此文件下的默认默认路径是否改变:mysql> show variables like "sevure_file_priv";
    1.2.数据导入
       1.2.1.什么是数据导入:
             把系统文件内容存储到数据库服务器的表里
       1.2.2.命令格式
          mysql>load data infile "目录/文件名" into table 库.表 fields terminated by "符号" line terminated by "\n";
       1.2.3.例子 把系统用户信息/etc/passwd存储到db3库下的user表里
             导入步骤:
             1、建库:mysql> create database db3;
             2、建表:
          mysql> create table db3.user(
                  -> username char(50),
                  -> password char(1),
                  -> uid int,
                  -> gid int,
                  -> comment varchar(150),
                  -> homedir char(50),
                  -> shell char(50));
              3、导入:把文件导入到数据库修改之后的默认路径/myload下  mysql> system cp /etc/passwd /myload
              4、把数据导入到数据库表并查看表:
             mysql> load data infile "/myload/passwd" into table db3.user fields terminated by ":" lines terminated by "\n";
             mysql> select * from db3.user;  
              5、扩展添加序列号,在表第一列插入一列表序列号:(可通过主键字段自加1实现)
             mysql> alter table db3.user add id int primary key auto_increment first;      
    1.3.数据导出
       1.3.1.什么是数据导出?  
             把记录保存到系统文件里
       1.3.2.命令格式与例子
       1.select 查询命令 into outfile "目录/文件名";
           例子:mysql> select * from db3.user where id<=2 into outfile "/myload/user1.txt";
       2.select 查询命令 into outfile "目录/文件名" fields terminated by "分隔符";例子如3
         3.以":"为分隔符\n换行倒出:select 查询命令 into outfile "目录/文件名" fields terminated by "分隔符" lines terminated by "\n"; 
           例子:mysql> select username,homedir,shell from db3.user where id<=2 into outfile "/myload/user5.txt" fields terminated by ":" lines terminated by "\n";
                                                               
二、管理表记录 
  2.1 添加记录 insert into(新添加的记录追加在记录末尾)
      2.1.1 添加1条记录给所有列赋值
         格式:insert into 表名 values (字段值列表);
      2.1.2 添加多条记录给所有列赋值
         格式:insert into 表名 values (字段值列表),(字段值列表),(字段值列表);
      2.1.3 添加1条记录给指定的列赋值
         格式:insert into 表名(字段名列表) values (字段值列表);
         例子:insert into db3.user(username,password,uid,gid,comment,homedir,shell) values("yaya100","x","1000","1000","","/home/yaya100","/bin/bash");
      2.1.4 添加多条记录给指定的列赋值
         格式:insert into 表名(字段名列表) values (字段值列表) (字段值列表);
         例子:mysql> insert into db3.user(username,id) values(null,1001),("null",1002),("",1003);
  2.2 查询记录 select (字段是列,条件是行)
       格式:select 字段名列表 from 表名 [where 条件];
       例子:mysql> select username,uid from db3.user where id <= 10;
  2.3 更新记录 update(修改;记录字段的值)
       格式:update 库名.表名 set 字段名=值,字段名=值 [ where 条件 ];
       例子:mysql> update db3.user set password="A",comment="root";
  2.4 删除记录 delete (以行为单位删除)
       格式:delete from 库.表 [ where 条件 ]
       例子:mysql> delete from db3.user where username="yaya100";
三、匹配条件[ where 条件 ] select、update、delete 记录 操作
  3.1 基本匹配条件(适用于select、update、delete 记录 操作)
        3.1.1 数值比较(必须是数值比较) =、>、>=(大于等于)、<、<=(小于等于)、!=(不等于) 
         例如:select username,uid from db3.user where uid=gid;
        3.1.2 字符比较字符且要双引号 =、!=
         例如显示shell为/bin/bash的数据:select username from db3.user where shell = "/bin/bash";
                                   select username from db3.user where shell != "/bin/bash";      
        3.1.3 范围匹配(in 在..里..)(between 数字 and 数字 在...之间)(distinct 去重显示)
         例如:mysql> select username from db3.user where username in ("sync","daemon","apache","mysql");
           mysql> select username from db3.user where uid in (0,1,2);
           mysql> select username from db3.user where uid between 10 and 20;
           mysql> select distinct shell from db3.user;
        3.1.4 匹配空及非空(is null空)(is not null非空)
          例子查看名字为空和非空:mysql> select username from db3.user where username is null;
                          mysql> select username from db3.user where username is not null;
        3.1.5 逻辑匹配(or或)(and与)(!或not是非)
           例如:mysql> select username,uid from db3.user where username="root" and uid=1;
            mysql> select username,uid from db3.user where username="root" or uid=1;
  3.2 高级匹配条件(适用于select、update、delete 记录 操作)
       3.2.1 模糊查询 like
             '_'表示一个字符like '____'显示4个字符的名字
             '%'表示0~n个字符like '%a%';
         例如:mysql> select username from db3.user where username like '___';
           mysql> select username from db3.user where username like '%a%';
           mysql> select username from db3.user where username like '__%__';
       3.2.2 正则匹配 regexp  ^ $ . [] *
            例如:mysql> select username from db3.user where username regexp '[at]';
             mysql> select username from db3.user where username regexp '^[at]';
             mysql> select username from db3.user where username regexp '[0-9]';
            
       3.2.3 四则运算 +-*/%
             例如:mysql> update db3.user set uid=uid+1 where uid<=5;
              mysql> select username,uid,gid,(uid+gid)/2 pjz from db3.user;
              mysql> select username,uid from db3.user where uid%2=0;
  3.3 操作查询结果(对查询后的数据做处理) 
     3.3.1 聚集函数
       avg(字段名) 统计字段平均值
       sum 统计字段和
       min 统计字段最小值
       max 统计字段最大值
       count 统计字段个数
       例子:select min(uid) from db3.user;
         mysql> select max(uid) from db3.user;
         mysql> select sum(uid) from db3.user;
         mysql> select count(uid) from db3.user;
         mysql> select count(username) from db3.user where shell="/sbin/nologin";
         mysql> select min(uid) from db3.user where uid >=10 and uid<=20;
      3.3.2 查询结果排序
           升序:mysql> select username,uid from db3.user where uid <=1000 order by uid asc;
           降序:mysql> select username,uid from db3.user where uid <=1000 order by uid desc;
      3.3.3 查询结果分组 group by 字段名;
         mysql> select shell from db3.user where uid <=100 group by shell;
            与去重显示执行结果一样但是过程不一样
         mysql> select shell from db3.user where uid <=100 group by shell;
      3.3.4 查询结果过滤 having 条件; 速度快
         mysql> select username,uid from db3.user where username is not null having uid=3;
            或mysql> select username,uid from db3.user where username is not null and uid=3;这个是两个条件一起查找,没有上面的条件查找快.
      3.3.5 限制查询结果显示行数 limit
            1 只显示查询结果的前几行  limit 2
           mysql> select username,uid from db3.user where id <=10 limit 2;
            2 只显示查询结果指定范围内的行 limit 2,3;  2是显示的起始行,3是显示总行数. 
           mysql> select username,uid from db3.user where id <=10 limit 2,3;
四、MySQL管理工具
   4.1 连接mysql服务的方式
      命令行、使用软件连接、连接脚本(php python java)
   4.2 安装图形软件管理数据库服务器
      50上安装phpMyAdmin包软件
     # yum -y install httpd php php-mysql
     # systemctl restart httpd 
     # systemctl enable httpd
     [student@room9pc01~]$ scp /linux-soft/03/mysql/phpMyAdmin-2.11.11-all-languages.tar.gz root@192.168.4.50:/root/
     # tar -zxvf phpMyAdmin-2.11.11-all-languages.tar.gz 
     # mv phpMyAdmin-2.11.11-all-languages /var/www/html/phpmyad
     # cd /var/www/html/phpmyad/
     # cp config.sample.inc.php config.inc.php
     # vim +17 config.inc.php(或第31行)单引号随便写一点东西 
     然后真机登录 firefox http://192.168.4.50/phpmyad
      root/tarena
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
####################################################################################################################################
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                  day4 授权和备份
一、用户授权
    1.1 什么是用户授权
        在数据库服务器上添加新的连接用户,在添加用户时可以设置访问权限及连接密码.默认数据库管理员root用户本机登陆有授权权限. 慢查询 mysqldumpshow
    1.2 命令格式
      grant 授权列表 on 库名 to 用户名@"客户端地址" identifited by "密码";
        权限列表:all、usage、select update insert、select update(字段1...字段N)
        库名:*.*(所有库所有表) 库名.*(一个库) 库名.表名(一张表)
        用户名:授权时自定义要有标识性,存储在mysql库的user表里
        客户端地址:%、192.168.4.%、192.168.4.1、localhost
    1.3 授权例子:服务端:grant all on *.* to mydba@"%" identified by "123qqq...A" with grant option;
                 客户端:mysql -h192.168.4.50 -umydba -p"123qqq...A" 
                 (扩展:information_schema是虚拟库只有看权限,内存库映射出来的虚拟库.)
    1.4 相关命令
              select user();                             显示当前登陆的用户名及客户端地址
              show grants;                               登录用户显示自身访问权限
              show grants for 用户名@"客户端地址";             显示管理员已授权的用户权限
                  例子:mysql> show grants for yaya@"localhost";
              set password=password("密码");              授权用户连接后修改连接密码
                  例子:mysql> set password=password("tarena");
              set password for 用户名@"客户端地址"=password(密码); 管理员重置授权用户连接密码
                  例子:mysql> set password for mydba@"%"=password("123qqq...A");
              drop user 用户名@"客户端地址"                      删除授权用户(必须有管理员权限)
                  例子:mysql> drop user yaya@"localhost";
    1.5 授权库mysql(记录授权信息mysql库的管理)可以查看表记录,查看到授权用户的授权信息,也可以通过修改记录,修改用户的权限
      1.5.1 user表(记录已有的授权用户及权限)
             查看:mysql> desc mysql.user;
              mysql> select host,user from user;
              mysql> select * from  user where host="%" and user="mydba" \G;
      1.5.2 db表   (记录已有授权用户对数据库的访问权限)
             查看:mysql> desc mysql.db;
              mysql> select host,db,user from db;
              mysql> select * from mysql.db where host="localhost" and db="db3" and user="admin2" \G;
                  修改库权限:mysql> update mysql.db set  Update_priv="N",Delete_priv="N" where host="localhost" and db="db3" and user="admin2";
                  刷新生效:mysql> flush privileges;
                  查看授权:mysql> show grants for admin2@"localhost";
             修改权限:同上 1.5.1
      1.5.3 tables_priv表(记录已有授权用户对表的访问权限)
             查看:mysql> desc tables_priv;
              mysql> select * from mysql.tables_priv;
              mysql> select * from mysql.tables_priv where db="db3" and table_name="user"\G;
              mysql> show grants for admin@"192.168.4.0/24";
             修改表权限:  
      1.5.4 columns_priv表(记录已有授权用户对字段的访问权限)
            添加一个用户对字段有权限:mysql> grant select,update(uid) on db3.user to yaya99@"%" identified by "123456";
             查看:mysql> desc mysql.columns_priv;
              mysql> select * from mysql.columns_priv;

    1.6 撤销授权 (删除已有授权用户的权限)撤销with grant option授权的权限以及其他权限
        格式:revoke 权限列表 on 库名.表 from 用户名@"客户地址";
        例子:mysql> select host,user from mysql.user;   
          mysql> show grants for mydba@"%";
          mysql> revoke grant option on *.* from mydba@"%";   删除在此用户下授权功能
          mysql> show grants for mydba@"%";

          mysql> revoke delete on *.* from mydba@"%";         删除授权过的删除权限
          mysql> show grants for mydba@"%";

          mysql> revoke all on *.* from mydba@"%";            删除授权的所有权限
          mysql> show grants for mydba@"%";
    1.7 删除授权用户
          mysql> drop user mydba@"%";
          mysql> select host,user from mysql.user;
    1.8 管理root密码
        1.8.1 恢复密码
        #systemctl stop mysqld
        vim /etc/my.cnf
          [mysqld]
             skip-grant-tables
             #validate_password_policy=0
             #validate_password_length=6
        #systemctl start mysqld              跳过密码启动服务程序
        #mysql
        mysql> desc mysql.user;
        mysql> select host,user,authentication_string from mysql.user;
        mysql> update mysql.user set authentication_string=password("A...qqq321") where host="localhost" and user="root";   修改密码
        mysql> flush privileges; 
        #systemctl stop mysqld
        vim /etc/my.cnf
          [mysqld]
             #skip-grant-tables
             validate_password_policy=0
             validate_password_length=6
        #systemctl start mysqld 
        #mysql -hlocalhost -uroot -pA...qqq321
          然后重启在恢复.
        1.8.2 修改密码(重置密码)
            #mysqladmin -hlocalhost -uroot -p password "123456"
               #旧密码
二、完全备份
    2.1 数据备份目的  数据丢失或损坏,可以使用
    2.2 数据备份方式
           物理备份冷备50
         #cp -r /var/lib/mysql /root/mysql.bak
         #tar -zcvf /root/mysql.tar.gz /var/lib/mysql
         #scp -r /root/mysql.bak root@192.168.4.51:/opt/
           物理恢复51
         #ss -anptu | grep 3306
         #systemctl stop mysqld
         #ss -anptu | grep 3306
         #rm -rf /var/lib/mysql
         #cp -r /root/mysql.bak/ /var/lib/mysql
         #chown -R mysql:mysql /var/lib/mysql
         #systemctl start mysqld
           
        逻辑备份  使用软件自带备份程序(备份命令)对数据做备份,在执行备份命令时,会根据已有的数据生成对应的命令,把命令存放到指定的备份文件里.
                  恢复时,执行备份文件里的命令恢复数据
                    
    2.3 数据备份策略
        完全备份:备份所有数据(可以是1张表、1个库、1台服务器)
        增量备份:只备份新产生数据,备份上次备份后,所有新产生的数据
        差异备份:只备份新产生数据,备份完全备份后,所有新产生的数据
       
    2.4 完全备份-----mysqldump命令
        --all-databases 或 -A     所有库
          数据库名                        单个库  db3
          数据库名 表名                   单张表  db3 user
        -B 库名 库名                   多个库  -B db1 db2 db3 
        格式:#mysqldump -uroot -p密码 库名 > 目录/xxx.sql
        例子:#mysqldump -uroot -ptarena --all-databases > /mybak/alldb.sql
          #mysqldump -uroot -ptarena db1 > /mybak/db1.sql
          #mysqldump -uroot -ptarena db3 user > /mybak/db3_user.sql
          #mysqldump -uroot -ptarena -B db1 db3 > /mybak/twodb.sql
    2.5 完全恢复-----mysql命令
        格式:#mysql -uroot -p密码 库名 < 目录/xxx.sql
        例子:#scp /mybak/db1.sql root@192.168.4.51:/root/
          #mysql -uroot -ptarena db1 < /root/db1.sql     注意:导入一个库或者一个表需要先创建这个库

          #mysql -uroot -ptarena < /root/twodb.sql           导入多个库和all不需要先创建库
三、增量备份  备份上次备份后,所有新产生的数据(使用mysql服务的binlog日志实现数据的增量备份与恢复)
   3.1 binlog日志的使用
        3.1.1 什么是binlog日志
             也称做二进制日志
          MySQL服务日志文件的一种
             记录除查询之外的所有SQL命令
             可用于数据备份和恢复
             配置mysql主从同步的必要条件  
         3.1.2 启用日志
           3.1.2.1 默认路径
           #vim /etc/my.cnf
               [mysql]
               server_id=50
               log_bin
           #systemctl restart mysqld 
              查看mysql>show master status       
             日志文件存放在#ls /varlib/mysql/host50* (/var/lib/mysql/host50-bin.000001  /var/lib/mysql/host50-bin.index 是索引存放日志的名称)
           3.1.2.2 自定义日志存储目录和日志文件名
           #mkdir /mylog           #创建自定义路径
           #chown mysql /mylog     #给权限
           #vim /etc/my.cnf
               [mysql]
               server_id=50
               log_bin=/mylog/lh     #自定义路径
           #systemctl restart mysqld
           #ls /mylog
              查看mysql>show master status                
         3.1.3 手动创建新的binlog日志文件
               #systemctl restart mysql
               mysql>flush logs
               或者#mysql -uroot -ptarena -e "flush logs"
               #mysqldump --flush-logs  做完备份之后在刷新一下生成的binlog日志文件
                   查看mysql>show master status
         3.1.4 删除已有的binlog日志
                删除4之前的binlog日志文件
                mysql> purge master logs to "lh.000004";
                删除所有binlog日志内容
               mysql> reset master;
         3.1.5 查看binlog日志内容   偏移量记录日志文件
            3.1.5.1 查看binlog日志内容 命令行查看
                #mysqlbinlog /mylog/lh.000001
                mysql> show master status;
            3.1.5.2 修改日志格式
                host50# scp /mylog/lh.000001 root@192.168.4.51:/root/
                   恢复数据:host51# mysql -uroot -ptarena -e "select count(*) from db3.user"
                            #mysqlbinlog /root/lh.000001 | mysql -uroot -ptarena 
                            #mysql -uroot -ptarena -e "select count(*) from db3.user"
                    修改日志记录格式:
                          三种记录方式
                           statement 报表模式
                           row 行模式
                           mixed 混合模式能查看到命令
				 2 查看默认使用的日志格式
mysql> show variables like "binlog_format";
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| binlog_format | ROW   |
+---------------+-------+

				 3 修改日志格式
]# vim /etc/my.cnf
[mysqld]
binlog_format="mixed"
:wq

[root@host50 ~]# systemctl  restart mysqld
[root@host50 ~]# mysql -uroot -p123456
mysql> show variables like "binlog_format";
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| binlog_format | MIXED |
+---------------+-------+
mysql> reset master;
                     #mysql -uroot -ptarena -e "show variables like 'binlog_format'"
                           
                           
            3.1.5.3 日志文件如何区分记录的多条sql命令
                       偏移量和时间点
                       命令格式:
                          偏移量
                           --start-position=1054 --stop-position=2098
                          时间点
                           --start-datetime="yyyy-mm-dd hh:mm:ss" --stop-datetime="yyyy-mm-dd hh:mm:ss"
    3.2 使用binlog日志恢复指定范围内的数据
        mysql> insert into db3.user(username) values("aliceA");
        mysql> insert into db3.user(username) values("aliceB");
        mysql> delete from db3.user where username like 'alice%';
        mysql> show master status;
        mysql> exit
        #mysqlbinlog /mylog/lh.000001 | grep -i delete
          
        host50# scp /mylog/lh.000001 root@192.168.4.51:/opt/
       
        host51#mysqlbinlog /opt/lh.000001
        host51#mysql -uroot -ptarena -e "select username from db3.user where username like 'alice%'"
        host51#mysqlbinlog --start-position=325 --stop-position=790 /opt/lh.000001 | mysql -uroot -ptarena
        host51#mysql -uroot -ptarena -e "select username from db3.user where username like 'alice%'"    

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
####################################################################################################################################
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                  day5 percona软件和innobackupex备份与恢复
以上学习备份的缺点:
物理备份:
         跨平台性差
         备份时间长、冗余备份、浪费存储空间
mysqldump备份缺点:
         效率较低、备份和还原速度慢、锁表
                  

1、percona软件介绍
  1.1 percona软件介绍
   1.2 安装软件
        安装两个包:
        #rpm -ivh libev-4.15-1.el6.rf.x86_64.rpm
        #yum -y install percona-xtrabackup-24-2.4.7-1.el7.x86_64.rpm 
   1.3 命令格式   完全备份和完全恢复
      --host    --user  --port  --password  --databases  --no-timestamp
      --redo-only --apply-log --copy-back                        完全备份 
      --incremental 目录名  --incremental-basedir=目录名 --incremental-dir=目录名  --export import  增量备份
     #innobackupex [选项] 
      完全备份格式:innobackupex --user 用户名 --passwoed 密码 备份目录名 --no-timestamp
               #innobackupex --user root --password tarena /allbak --no-timestamp
               #scp -r /allbak/ root@192.168.4.51:/root/
      完全恢复格式:  --aapply-log 目录名   准备恢复数据
                 --copy-back 目录名   恢复数据
      
      例子步骤如下:
         完全备份:
       host50#innobackupex --user root --password tarena /allbak --no-timestamp
       host50#scp -r /allbak/ root@192.168.4.51:/root/
         完全恢复:
            1 停止数据库服务器
            2 清空数据库目录
            3 准备恢复数据
            4 拷贝数据
            5 修改数据库目录的所有者和组用户为mysql
            6 启动服务
            7 管理员登录查看数据
      100   systemctl stop mysqld
      101  cd /var/lib/mysql
      102  ls
      103  rm -rf *
      104  ls
      105  innobackupex --apply-log /root/allbak/       准备恢复数据                
      106  innobackupex --copy-  /root/allbak/       开始恢复数据
      107  ls -ld /var/lib/mysql
      108  ls -l /var/lib/mysql
      109  chown -R mysql:mysql /var/lib/mysql          给所有者和组为mysql
      110  ls -l /var/lib/mysql
      113  systemctl start mysqld
      114  ss -anptu | grep 3306
        查看存储引擎mysql> show engines;
    
    1.4 恢复单张表 (.frm 存储表结构    .ibd 存储表数据表空间文件)
        具体操作如下:
                   1 删除表空间      alter table 库名.表名 discard tablespace
                   2 导出表信息      innobackupex --apply-log --export 数据完全备份目录
                   3 拷贝表信息文件到数据库目录下  
                   4 修改表信息文件的所有者及组用户为mysql
                   5 导入表空间
                   6 删除数据库目录下的表信息文件
                   7 查看表记录
          1 mysql> alter table db5.b discard tablespace;
          2 #innobackupex --apply-log --export /root/allbak/
          3 #cp /root/allbak/db5/b.{cfg,exp,ibd} /var/lib/mysql/db5/
          4 #chown -R mysql:mysql /var/lib/mysql/db5/b.*
          5 mysql> alter table db5.b import tablespace;
            mysql> select * from db5.b;
          6 #rm -rf /var/lib/mysql/db5/b.cfg
            #rm -rf /var/lib/mysql/db5/b.exp 
          7 mysql> select * from db5.b;
    
    1.5 innobackupex增量备份与恢复
          首次备份:做完全备份
        #cat /allbak/xtrabackup_checkpoints
         
           增量备份格式:#innobackupex --user 用户名 --password 密码 --incremental 增量目录 --incremental-basedir=目录名 --no-timestamp
           增量恢复格式:#innobackupex --apply-log --redo-only 目录名 --incremental-dir=增量目录
                   #innobackupex --copy-back 目录名
         
          例子:增量备份
           host50#innobackupex --user root --password tarena /allbak --no-timestamp
           host50#innobackupex --user root --password tarena --incremental /new1dir --incremental-basedir=/allbak --no-timestamp
           host50#innobackupex --user root --password tarena --incremental /new2dir --incremental-basedir=/new1dir --no-timestamp
              
           host50#scp -r /allbak/ root@192.168.4.51:/opt
           host50#scp -r /new1dir/ root@192.168.4.51:/opt
           host50#scp -r /new2dir/ root@192.168.4.51:/opt
               
              增量恢复
           host51#innobackupex --apply-log --redo-only /opt/allbak/                                 准备恢复数据合并数据
           host51#innobackupex --apply-log --redo-only /opt/allbak/ --incremental-dir=/opt/new1dir  与new1合并,增量数据也会合allbak上
           host51#innobackupex --apply-log --redo-only /opt/allbak/ --incremental-dir=/opt/new2dir  与new2合并,增量数据也会合allbak上      
           host51#systemctl stop mysqld
           host51#rm -rf /var/lib/mysql/*
           host51#innobackupex --copy-back /opt/allbak/           
           host51#chown -R mysql:mysql /var/lib/mysql/
           host51#systemctl start mysqld
           host51#ss -anptu | grep 3306
      验证    host51#mysql -uroot -ptarena
      查库    mysql> show databases; 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
####################################################################################################################################
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                  day6 主从同步   ftp://172.40.50.117/2019/homework/
 
一、mysql主从同步
      异步复制:
      全同步复制:
      半同步复制:

    1.1 主从同步介绍
    1.2 主从同步原理
       Master
             启用binlog日志
       Slave
            -Slave_IO:复制master主机binlog日志文件里的SQL命令到本机的relay-log文件里
            -Slave_SQL:执行本机relay-log文件里的SQL语句,实现与Master数据一致 

      存放数据库目录下的文件:
            master.info             主库信息
            relay-log.info          中继日志信息
               主机名-relay-bin.000001   中继日志
               主机名-relay-bin.index    索引文件
    1.3 配置主从服务器
       配置主服务器:
           1 启用binlog日志
           2 授权用户
           3 查看binlog日志信息
       配置从服务器:
           1 设置server_id
           2 确保与主服务器数据一致
           3 指定主库信息
           4 启动slave程序
           5 查看状态
       配置:
       主:
      1 vim /etc/my.cnf
       [mysqld] 
         server_id=51
         log-bin=master51
        #systemctl restart mysqld
        #ls /var/lib/mysql/master51.*
        #mysql -uroot -p123456
         > show master status;       查看binlog日志内容
       2 > grant replication slave on *.* to repluser@"%" identified by "123qqq...A";  检查主从的状态权限
       3 > show grants for repluser@"%";     
       从:
     host51#systemctl restart mysqld
     host51#mysqldump -uroot -p123456 --master-data db5 > /root/db5.sql
     host51#scp /root/db5.sql root@192.168.4.52:/opt/
     host52#vim /etc/my.cnf
           [mysqld]
           server_id=52
     host52#mysql -uroot -p123456 db5 < /opt/db5.sql
     host52#mysql -uroot -p123456 db5 -e "use db5;show tables" 
     host52#grep master51 /opt/db5.sql
     host52#mysql -uroot -p123456
            mysql> show slave status  \G;
            mysql> change master to master_host="192.168.4.51",master_user="repluser",
                   master_password="123qqq...A",master_log_file="master51.000002",master_log_pos=154;
            mysql> start slave;
            mysql> show slave status  \G;
                   Slave_IO_Running: Yes        
                   Slave_SQL_Running: Yes

    
     4 排错 
     1 mysql> stop slave;
       mysql> change master to [选项]=值 
       mysql> start slave;
     2 host52#cat /var/lib/mysql/master.info 主库信息,查看从服务器配置的change master to 命令的参数
       mysql> stop slave;
       mysql> change master to [选项]=值 
       mysql> start slave;
     3 relay-log.info 中继日志信息
       mysql> stop slave;
       #rm -rf master.info relay-log.info host52-relay*
      4 vim /var/lib/mysql/auto.cnf   更改UUID 是克隆出来的
     Last_IO_Error:Got fatal error 1236 from master when reading data from binary log: 'Could not find first log file name in binary log index file'

     1.5.1 在主服务器添加授权用户给客户端连接使用
]# mysql  -uroot  -p123456
mysql> create database db1;
mysql> grant all on  db1.*  to  admin@"%" identified by "123qqq...A";
mysql> grant select,insert,update,delete on db5.* to admin@"%";
mysql> 
		1.5.2 客户端使用授权用户连接主服务器，访问数据
[root@host50 ~]# mysql -h192.168.4.51 -uadmin -p123qqq...A
mysql> show grants;
mysql> delete from  db5.b where name="lucy";
mysql> show master status;
mysql> update db5.b set name="jerry" where name="bob";
mysql> create table db1.a(id int);
mysql> insert into db1.a values(100);

		1.5.3 在从服务器主机查看数据（能够看到和主服务器同样的数据）
[root@host52 ~]# mysql -uroot -p123qqq...A
mysql> show slave status\G;
Last_SQL_Error: Error 'Operation DROP USER failed for 'admin'@'192.168.4.%'' on query. Default database: ''. Query: 'drop user admin@"192.168.4.%"'
  Replicate_Ignore_Server_Ids:	 
mysql> stop slave;
mysql> grant all on *.* to  admin@"192.168.4.%" identified by "123qqq...A";
mysql> start slave;
mysql> show slave status\G;

mysql> select  * from db5.b;
mysql> select  * from db5.b;
mysql> select  * from db1.a;
     
      5 主从从
      6 主主
           

二、复制模式
    主从同步模式类型:
                      异步复制模式(默认)

                      全同步复制模式
                      半同步复制模式
                      介于异步复制和全同步复制之间
                                  查看主从状态:#mysql -uroot -p123456 -e "show slave status\G" | grep -i yes
                             命令:
                           mysql> show variables like "have_dynamic_loading";
                           mysql> install plugin rpl_semi_sync_master SONAME "semisync_master.so";    主服务器上加载模块
                           mysql> install plugin rpl_semi_sync_slave SONAME "semisync_slave.so";      从服务器上加载模块
                           mysql> select plugin_name,plugin_status from information_schema.plugins where plugin_name like "%semi%";

                           mysql> set global rpl_semi_sync_master_enabled=1; 主服务器启动半同步复制
                           mysql> set global rpl_semi_sync_slave_enabled=1;  从服务器启动半同步复制
                           mysql> show variables like "rpl_semi_sync_%_enabled";
                       host56即做主又做从
                              配置文件用就生效:
                       #vim /etc/my.cnf            
                        [mysqld]
                           plugin-load="rpl_semi_sync_master=semisync_master.so;rpl_semi_sync_slave=semisync_slave.so"
                           rpl_semi_sync_master_enabled=1
                           rpl_semi_sync_slave_enabled=1
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
####################################################################################################################################
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                  day7 数据读写分离和MySQL多实例  50 57* 51 52
一、数据读写分离
     1.1 什么是数据读写分离
          把客户端访问数据的读请求(select)和写请求(insert、update、delete)分别分配给不同的数据库服务器处理
     1.2 如何实现客户端访问数据的读写分离
             1 通过程序实现(代码里实现)
             2 配置服务实现(在服务器上安装软件:mysql-proxy、mycat、maxscale 实现读写分离)
                 中间件:mysql-proxy、 mycat、 maxscale
             3 为什么要配置读写分离(51、52主从关系,实现分流减轻51主服务器的压力) 
      1.3 配置数据读写分离
          1 配置mysql 主从同步,把52配置51的从服务器	
          2 搭建mysql代理服务器 
              * 安装提供服务的软件包 主配置文件/etc/maxscale.cnf,日志文件/var/log/maxscale/
               #rpm -ivh maxscale-2.1.2-1.rhel.7.x86_64.rpm
              * 修改服务的主配置文件/etc/maxscale.cnf
                     9  更改线程数量auto 
                     18 服务器IP
                     35 定义监控的服务器
                     52 不定义只读,全注释
                     63 定义读写分离服务
                     75 定义管理服务,不用更改
                     85 读写分离端口号
                     98 更改管理服务端口号
                  vim /etc/maxscale.cnf
                     [maxscale]
                     threads=auto  表示线程数量   进程里面的最小工作单位(进程独享资源,线程共享资源)

                     [server1]
                     type=server
                     address=192.168.4.51
                     port=3306
                     protocol=MySQLBackend

                     [server2]
                     type=server
                     address=192.168.4.52
                     port=3306
                     protocol=MySQLBackend

                     [MySQL Monitor]
                     type=monitor
                     module=mysqlmon
                     servers=server1,server2
                     user=maxscalemon
                     passwd=123qqq...A
                     monitor_interval=10000

                    [Read-Write Service]
                    type=service
                    router=readwritesplit
                    servers=server1,server2
                    user=maxscalerouter
                    passwd=123qqq...A
                    max_slave_connections=100%

                   [Read-Write Listener]
                   type=listener
                   service=Read-Write Service
                   protocol=MySQLClient
                   port=4006

                   [MaxAdmin Listener]
                   type=listener
                   service=MaxAdmin Service
                   protocol=maxscaled
                   socket=default
                   port=4016
               * 添加授权用户
                    host51直接同步:
                    mysql> grant replication slave,replication client on *.* to maxscalemon@'%' identified by "123qqq...A";定义用户监视server1 2,确认主从进行读写分离.获取状态信息  主从和监控运行状态的权限
                    mysql> grant select on mysql.* to maxscalerouter@"%" identified by "123qqq...A"; 路由用户,50登录jim,在57上用maxscalerouter这个用户去server1 2上查看有没有登录的jim用户
                    mysql> select host,user from mysql.user; 
               * 启动代理服务
                    #maxscale -f /etc/maxscale.cnf   启动进程
                    #killall -9 maxscale             关闭进程
                    #ps -C maxscale   查看进程
                             

               * 验证配置                                           
                      1 在代理服务器本机连接管理服务,查看监控信息
                    #maxadmin -uadmin -pmariadb -P4016 
                    MaxScale> list servers
Servers.
-------------------+-----------------+-------+-------------+--------------------
Server             | Address         | Port  | Connections | Status              
-------------------+-----------------+-------+-------------+--------------------
server1            | 192.168.4.51    |  3306 |           0 | Master, Running
server2            | 192.168.4.52    |  3306 |           0 | Slave, Running
-------------------+-----------------+-------+-------------+--------------------
                      2 客户端连接代理访问数据
                     在主服务器51 添加访问数据连接用户
                   mysql> create database db7;
                   mysql> create table db7.a(id int);
                   host51> grant select,insert on db7.* to jim@"%" identified by "123qqq...A";  首先要在主mysql添加一个jim的授权用户
                   host50# mysql -h192.168.4.57 -P4006 -ujim -p123qqq...A    
                      3 客户端验证读写分离
                        从服务器添加一个数据,在客户端登录代理查看数据是在从服务器上查看的
                       host52 mysql> insert into db7.a values(52);
                              mysql> select * from db7.a;
                       host50#mysql -h192.168.4.57 -P4006 -ujim -p123qqq...A
                              mysql> select * from db7.a;
二、mysql多实例(在192.168.4.50主机做)
 2.1 多实例:在1台服务器上运行多个数据库服务器
 2.2 为什么要用多实例:节约运维成本,提高硬件利用率
 2.3 配置mysql多实例
     1 安装提供多实例服务软件
       真机找包#scp mysql-5.7.20-linux-glibc2.12-x86_64.tar.gz root@192.168.4.50:/opt/

      host50#tar -zvxf mysql-5.7.20-linux-glibc2.12-x86_64.tar.gz
             mv mysql-5.7.20-linux-glibc2.12-x86_64 /usr/local/mysql
             ls /usr/local/mysql/
     2 编辑主配置文件/etc/my.cnf
      [mysqld_multi]                                #启用多实例
      mysqld=/usr/local/mysql/bin/mysqld_safe       #指定进程文件路径
      mysqladmin=/usr/local/mysql/bin/mysqladmin    #指定管理命令路径
      user=root                                     #指定系统进程用户

      [mysqld1]                                     #实例进程名称,1表示实例标号
      port=3307                                     #端口号
      datadir=/dir1                                 #数据库目录,要手动创建
      socket=/dir1/mysqld1.sock                       #指定sock文件的路径和名称
      pid-file=/dir1/mysqld1.pid                     #进程pid号文件位置
      log-error=/dir1/mysqld1.err                    #错误日志位置

      [mysqld2]                                     #实例进程名称,1表示实例标号
      port=3308                                     #端口号
      datadir=/dir2                                 #数据库目录,要手动创建
      socket=/dir2/mysqld2.sock                       #指定sock文件的路径和名称
      pid-file=/dir2/mysqld2.pid                     #进程pid号文件位置
      log-error=/dir2/mysqld2.err                    #错误日志位置

     3 启动服务
     [root@host50 mysql]# /usr/local/mysql/bin/mysqld_multi start 1
     [root@host50 mysql]# /usr/local/mysql/bin/mysqld_multi start 2
     4 查看服务状态
      #ss -anptu | grep 3307
      #netstat -utnlp | grep :3307 
     5 使用原始密码登录mysql服务
      #/usr/local/mysql/bin/mysql -uroot -p'uAS;Ecq#h0Rr' -S /dir1/mysqld1.sock
      #/usr/local/mysql/bin/mysql -uroot -p'apoy.P=/g6Yj' -S /dir2/mysqld1.sock
      mysql> set password=password("123456");
     6 停止多实例服务
      #/usr/local/mysql/bin/mysqld_multi --user=root --password=123456 stop 1
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
####################################################################################################################################
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                         day8 数据分片   (50 56* 53 54 55)


一、数据分片
   1.1 分库/分表
      什么是分库分表?
          将存放在一台数据库服务器中的数据,按照特定方式进行拆分,分散存放到多台数据库服务器中,以达到分散单台服务器负载效果  
      水平分割
         按照表中指定字段的分片规则,将表记录按行切分,分散存储到多个数据库中,如1-10000在53的db1.a,10001-20000在54的db1.a.
      垂直分割
          将单个数据库的多个表按业务类型分类,分散存储到不同的数据库.
  1.2 mycat用于数据分片
       mycat是基于java的分布式数据库系统中间件,为高并发环境的分布式存储提供解决方案   
     --适合数据大量写入的存储需求
     --支持mysql、Oracle、Sqlserver、Mongodb等
     --提供数据读写分离服务
     --提供数据分片服务
     --基于阿里巴巴Cobar进行研发的开源软件

    mycat支持提供10中分片规则:
       1 枚举法 sharding-by-intfile
       2 固定分片 rule1
       3 范围约定 auto-sharding-long
       4 求模法 mod-long
       5 日期列分区发 sharding-by-date
       6 通配取模 sharding-by-pattern
     7 ASCII码求模通配
       8 编程指定 sharding-by-pattern
       9 字符串拆分hash解析 sharding-by-stringhash
       10 一致性hash sharding-by-murmur
    
      工作过程:
         当mycat收到一个SQL命令时
         解析SQL命令涉及到的表
         然后看对表的配置,如果有分片规则则获取SQL命令里分片字段值,并分配分片函数,获得分片列表
         然后将SQL命令发往对应的分片服务器去执行
         最后收集和处理所有分片结果数据,并返回到客户端
   
       配置mycat服务器:
       * mycat是java的软件需要装jdk.
               #yum -y install java-1.8.0-openjdk
               #which java
               #java -version
         * 装包   
          56#tar -zxvf Mycat-server-1.6-RELEASE-20161028204710-linux.tar.gz
          #mv mycat /usr/local/          
         * 修改配置文件   .xml服务的主配置文件  .txt 和 .properties是分片规则配置文件
                 1.定义连接用户个逻辑库名 rule.xml分片规则
                  [root@host56 ~]# vim /usr/local/mycat/conf/server.xml(使用默认配置)  设置连接账号及逻辑库
                  [root@host56 ~]# vim /usr/local/mycat/conf/schema.xml  配置数据分片
<?xml version="1.0"?>
<!DOCTYPE mycat:schema SYSTEM "schema.dtd">
<mycat:schema xmlns:mycat="http://io.mycat/">

        <schema name="TESTDB" checkSQLschema="false" sqlMaxLimit="100">
                <!-- auto sharding by id (long) -->
                <table name="travelrecord" dataNode="dn1,dn2,dn3" rule="auto-sharding-long" />

                <table name="company" primaryKey="ID" type="global" dataNode="dn1,dn2,dn3" />
                <table name="goods" primaryKey="ID" type="global" dataNode="dn1,dn2,dn3" />
                <table name="hotnews" primaryKey="ID" autoIncrement="true" dataNode="dn1,dn2,dn3"
                           rule="mod-long" />
                <table name="employee" primaryKey="ID" dataNode="dn1,dn2,dn3"
                           rule="sharding-by-intfile" />
                <table name="customer" primaryKey="ID" dataNode="dn1,dn2,dn3"
                           rule="sharding-by-intfile">
                        <childTable name="orders" primaryKey="ID" joinKey="customer_id"
                                                parentKey="id">
                                <childTable name="order_items" joinKey="order_id"
                                                        parentKey="id" />
                        </childTable>
                        <childTable name="customer_addr" primaryKey="ID" joinKey="customer_id"
                                                parentKey="id" />
                </table>
        </schema>
        <dataNode name="dn1" dataHost="localhost53" database="db1" />
        <dataNode name="dn2" dataHost="localhost54" database="db2" />
        <dataNode name="dn3" dataHost="localhost55" database="db3" />
        <dataHost name="localhost53" maxCon="1000" minCon="10" balance="0"
                          writeType="0" dbType="mysql" dbDriver="native" switchType="1"  slaveThreshold="100">
                <heartbeat>select user()</heartbeat>
                <writeHost host="hostM1" url="192.168.4.53:3306" user="lhyaya"
                                   password="123qqq...A">
                </writeHost>
        </dataHost>

        <dataHost name="localhost54" maxCon="1000" minCon="10" balance="0"
                          writeType="0" dbType="mysql" dbDriver="native" switchType="1"  slaveThreshold="100">
                <heartbeat>select user()</heartbeat>
                <writeHost host="hostM2" url="192.168.4.54:3306" user="lhyaya"
                                   password="123qqq...A">
                </writeHost>
        </dataHost>

        <dataHost name="localhost55" maxCon="1000" minCon="10" balance="0"
                          writeType="0" dbType="mysql" dbDriver="native" switchType="1"  slaveThreshold="100">
                <heartbeat>select user()</heartbeat>
                <writeHost host="hostM3" url="192.168.4.55:3306" user="lhyaya"
                                   password="123qqq...A">
                </writeHost>
        </dataHost>

</mycat:schema>


                 2.定义要分片的表
                  #cp  /usr/local/mycat/conf/schema.xml /root/
                  #sed -i '56,77d' /usr/local/mycat/conf/schema.xml
                  #sed -i '39,42d' /usr/local/mycat/conf/schema.xml
                  #sed -i '16,18d' /usr/local/mycat/conf/schema.xml
                  #wc -l /usr/local/mycat/conf/schema.xml
                 
                3.配置数据库服务器
                   3.1 创建存储数据的库
                          53 54 55 分别添加库db1 db2 db3     host53 mysql> create database db1;
                                                    host54 mysql> create database db2;
                                                    host55 mysql> create database db3;
                   3.2 添加mycat连接用户
                           53 54 55 都需要添加授权用户:   grant all on *.* to pljyaya@"%" identified by "123qqq...A";
                 4.启动服务
               #/usr/local/mycat/bin/mycat start
               #/usr/local/mycat/bin/mycat stop     
                 5.查看状态
               [root@host56 mycat]# ss -anptu | grep 8066
               [root@host56 mycat]# /usr/local/mycat/bin/mycat status
               [root@host56 mycat]# ls /usr/local/mycat/logs/
                 6.排错
                 7.测试配置 
                    看规则[root@host56 ~]# vim /usr/local/mycat/conf/schema.xml里的sharding-by-intfile,单后查找rule.xml对应的hash-int,在找           partition-hash-int.txt的文件


                   7.1 客户端连接分片服务器查看数据
                  [root@host50 ~]# mysql -h192.168.4.56 -uroot -p123456 -P8066
                   7.2 分片规则
                      7.2.1 枚举法 sharding-by-intfile
                             字段值必须在列举范围内选择  56上查看sharding-by-intfile(分别去53 54 55查看)水平分割
[root@host50 ~]# mysql -h192.168.4.56 -uroot -p123456 -P8066
mysql> create table employee(ID int primary key auto_increment,sharding_id int,name char(15),home char(50),sex enum("man","woman"));

                      7.2.2 求模法 mod-long(水平分割)创表添加数据
                             根据字段值与设定的数字求模结果存储数据
      [root@host50 ~]# mysql -h192.168.4.56 -uroot -p123456 -P8066
      mysql> create table hotnews(id int,title char(50),comment char(100),worker char(20),up_time datetime);
      mysql> insert into hotnews(id,title,comment,worker,up_time) values(7,"linux","apache server","nb",now()),(8,"shell","pxe         shell","wk",20190601090000), (9,"ope","nginx vpc","dmy",20190701090000),(10,"mysql","master-slave","plj",now());
                      7.2.3 没有规则就不分割 类型是type="global"

                      7.2.4 在分片服务器mycat添加新库新表
                            * 添加新库 
                [root@host56 ~]# vim /usr/local/mycat/conf/server.xml
                <user name="root">
                <property name="password">123456</property>
                <property name="schemas">TESTDB,GAME</property>
                             * 添加新表
                 [root@host56 ~]# vim /usr/local/mycat/conf/schema.xml
                                <schema name="GAME" checkSQLschema="false" sqlMaxLimit="100">
                                <table name="game_user" dataNode="dn1,dn2,dn3" rule="mod-long" />
                                <table name="game_pople" primaryKey="ID" dataNode="dn1,dn2,dn3"
                                           rule="sharding-by-intfile" />
                                </schema>
                             * 重启服务生效
                        #/usr/local/mycat/bin/mycat stop
                        #/usr/local/mycat/bin/mycat start

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
####################################################################################################################################
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                         day9 mysql集群MHA   (50 57* 51 52 53 100)

集群知识回顾:
          集群分类           LB     负载均衡集群         相对应软件:       LVS、 Nginx、 Haproxy
                       HA      高可用(主备)集群                      keepalived针对所有服务都可用、  MHA(只对mysql服务的高可用集群)
                       HPC     高性能计算集群         

一、MHA集群
   MHA介绍:
   1.2 部署MHA集群:
       1.2.1 环境准备
             * 安装依赖包   
                   系统软件的perl和下载的perl包
                   真机传包:         真机 ]$ scp -r mha-soft-student/ root@192.168.4.57:/opt/
                  (51 52 53 57全装)  #yum -y install perl-*  本机直接通过yum安装perl包
                             #cd /opt/mha-soft-student/
                             #yum -y install perl-*.rpm  下载传到本机安装的perl包
             * 无密码认证登录
                 1 管理主机无密码连接所有数据库服务器 (以51举例然后以下同理)
                   host57# ssh-keygen
                   host57# ssh-copy-id root@192.168.4.51
                   host57# ssh-copy-id root@192.168.4.52
                   host57# ssh-copy-id root@192.168.4.53
                             52 53 57 同理
                 2 数据库彼此之间无密码连接
                            同1
                 3 一主多从服务配置
               host51#vim /etc/my.cnf
                      [mysqld]
                      server_id=51
                      log-bin=master5
               host51#mysql -uroot -p123456
                       mysql> grant replication slave on *.* to repluser@"%" identified by "123qqq...A";
                       mysql>exit
               host51#systemctl restart mysqld 
               host51#mysql -uroot -p123456
mysql> show master status;
+-----------------+----------+--------------+------------------+-------------------+
| File            | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+-----------------+----------+--------------+------------------+-------------------+
| master51.000007 |      154 |              |                  |                   |
+-----------------+----------+--------------+------------------+-------------------+
                             

                host52#vim /etc/my.cnf
                       [mysqld]
                       server_id=52
                host52#mysql -uroot -p123456
                mysql> change master to master_host="192.168.4.51",master_user="repluser",master_password="123qqq...A",master_log_file="master51.000007",master_log_pos=154;
                mysql> start slave;
                mysql> show slave status\G;


                host53#vim /etc/my.cnf
                       [mysqld]
                       server_id=52
                host53#mysql -uroot -p123456
                mysql> change master to master_host="192.168.4.51",master_user="repluser",master_password="123qqq...A",master_log_file="master51.000007",master_log_pos=154;
                mysql> start slave;
                mysql> show slave status\G;
                    
       1.2.2 配置管理主机 
            * 前提是perl包都装好在装管理主机软件包:(管理主机上node和manager都需要装)
             host57#cd /opt/mha-soft-student/
             host57#rpm -ivh mha4mysql-node-0.56-0.el6.noarch.rpm   先装node节点包
             host57#which perl
             host57#tar -xf mha4mysql-manager-0.56.tar.gz           在装manager管理包
             host57#cd mha4mysql-manager-0.56/ 
             host57#perl Makefile.PL
             host57#make
             host57#make install
            * 编辑主配置文件vim /etc/mha/app1.cnf
             host57#mkdir /etc/mha
             host57#cp /opt/mha-soft-student/mha4mysql-manager-0.56/samples/conf/app1.cnf /etc/mha/
             #vim /etc/mha/app1.cnf
[server default]
manager_workdir=/etc/mha
manager_log=/etc/mha/manager.log
master_ip_failover_script=/etc/mha/master_ip_failover     故障切换脚本

ssh_user=root               ssh用户
ssh_port=22

repl_user=repluser          同步授权用户
repl_password=123qqq...A

user=root                    监控用户
password=123qqq...A

[server1]
hostname=192.168.4.51
port=3306
candidate_master=1           竞选主库

[server2]
hostname=192.168.4.52
port=3306
candidate_master=1

[server3]
hostname=192.168.4.53
port=3306
candidate_master=1

            * 修改故障切换脚本 指定vip地址 192.168.4.100
              host57#cp /opt/mha-soft-student/master_ip_failover /etc/mha/
              host57#chmod +x /etc/mha/master_ip_failover                    给脚本权限
              host57#vim /etc/mha/master_ip_failover
                        改成192.168.4.100

       1.2.3 配置数库服务器(数据节点)
              * 先安装node软件
              host51#rpm -ivh mha4mysql-node-0.56-0.el6.noarch.rpm
              host51#rpm -ivh mha4mysql-node-0.56-0.el6.noarch.rpm                    
              host51#rpm -ivh mha4mysql-node-0.56-0.el6.noarch.rpm
              * 在主库部署VIP地址(上面的脚本只负责主库坏了才把VIP迁移,第一次不会主动部署主库的vip,所以第一次的主库VIP要手动配置上去)
              host51#ifconfig eth0:1 192.168.4.100/24
              host51#ifconfig eth0:1
              * 添加授权用户root,自动同步 52、53 
              host51#mysql> grant all on *.* to root@"%" identified by "123qqq...A";
              * 在从52和53添加同步数据的连接用户repluser
              host52#mysql>grant replication slave on *.* to repluser@"%" identified by "123qqq...A";
              host53#mysql>grant replication slave on *.* to repluser@"%" identified by "123qqq...A";  
              * 52和53上启用binlog日志文件
                  log-bin=master51
              * 在所有数据库服务器设置禁止自动删除本机的中继日志文件
                  relay_log_purge=0    
              * 在所有数据库服务器启用半同步复制模式
                  plugin-load="rpl_semi_sync_master=semisync_master.so;rpl_semi_sync_slave=semisync_slave.so"
                  rpl_semi_sync_master_enabled=1     
                  rpl_semi_sync_slave_enabled=1

总配置 51、52、53:
]# vim /etc/my.cnf
server_id=51
log-bin=master51
relay_log_purge=0
plugin-load="rpl_semi_sync_master=semisync_master.so;rpl_semi_sync_slave=semisync_slave.so"
rpl_semi_sync_master_enabled=1
rpl_semi_sync_slave_enabled=1
       1.2.4 验证配置
              * 验证ssh配置
                 #masterha_check_ssh --conf=/etc/mha/app1.cnf
              * 验证主从同步
                 #masterha_check_repl --conf=/etc/mha/app1.cnf
                 MySQL Replication Health is OK.
              * 验证
[root@host51 ~]# mysql -uroot -p123qqq...A
mysql> create database db9;
mysql> create table db9.a (id int);
mysql> grant select , insert on  db9.*  to yaya55@"%" identified by "123qqq...A";
mysql> show grants for yaya55@"%";
+-------------------------------------------------+
| Grants for yaya55@%                             |
+-------------------------------------------------+
| GRANT USAGE ON *.* TO 'yaya55'@'%'              |
| GRANT SELECT, INSERT ON `db9`.* TO 'yaya55'@'%' |
+-------------------------------------------------+
mysql>  exit ;
[root@host50 ~]# mysql -h192.168.4.100  -uyaya55  -p123qqq...A
mysql> select  * from db9.a;
Empty set (0.01 sec)

mysql> insert into db9.a values(110);
mysql> select  * from db9.a;
+------+
| id   |
+------+
|  110 |
+------+
mysql>
       1.2.5 启动管理服务
                 先检查51上的192.168.4.100 ip是否配置
             host57#masterha_manager --conf=/etc/mha/app1.cnf --remove_dead_master_conf --ignore_last_failover

             host57#masterha_check_status --conf=/etc/mha/app1.cnf 
       1.2.6 测试集群的高可用功能
              在主服务器51上添加授权用户(主切换52或53)监控会跳出来
                host51#systemctl stop mysqld
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
####################################################################################################################################
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                              day10 PXC和MySQL存储引擎   (50 71 72 73)                    
MHA 需要配置一主多从
比较繁琐
PXC 是基于高可用集群方案  同步多主复制插件

PXC特点:
      数据强一致性,无同步延迟
      没有主从切换操作,无需使用VIP
      支持InnoDB存储引擎
      多线程复制
      部署使用简单
      支持节点自动加入,无需手动拷贝数据

端口服务:
3306 数据库服务端口
4444 SST端口
4567 集群通信端口
4568 IST端口
SST State Snaphot Transfer全量同步
IST Incremental State Transfer增量同步

以下是开始配置  rm -rf /var/lib/mysql
* 71-73 配置:
vim /etc/hosts
192.168.4.71 pxcnode71
192.168.4.72 pxcnode72
192.168.4.73 pxcnode73

* 安装软件 按顺序装
#rpm -ivh libev-4.15-1.el6.rf.x86_64.rpm
#yum -y install percona-xtrabackup-24-2.4.13-1.el7.x86_64.rpm
#rpm -ivh qpress-1.1-14.11.x86_64.rpm
#tar -xvf Percona-XtraDB-Cluster-5.7.25-31.35-r463-el7-x86_64-bundle.tar
#yum -y install Percona-XtraDB-Cluster-*.rpm

* 配置文件3台都要配置]#vim /etc/percona-xtradb-cluster.conf.d/mysqld.cnf 
  -mysqld.cnf         //数据库服务运行参数配置文件
  -mysqld_safe.cnf   //Percona Server 5.7 配置文件
  -wsrep.cnf        //PXC集群配置文件
  

  71-73#vim /etc/percona-xtradb-cluster.conf.d/mysqld.cnf
     [mysqld]
      server-id=73
        其他配置都是默认就行
  71-73#vim /etc/percona-xtradb-cluster.conf.d/mysqld_safe.cnf  默认就行不需要配置
  71-73#vim /etc/percona-xtradb-cluster.conf.d/wsrep.cnf
      8  wsrep_cluster_address=gcomm://192.168.4.71,192.168.4.72,192.168.4.73 其群成员列表3台一样
     25  wsrep_node_address=192.168.4.71                                      P1IP
     27  wsrep_cluster_name=pxccluster                                        集群名3台必须相同
     30  wsrep_node_name=pxcnode71                                            P1主机名
     39  wsrep_sst_auth="sstuser:123qqq...A"                                  SST同步使用的用户名和密码3台一样

* 启动服务 在一台服务器上启动就行
          pxcnode71#systemctl start mysql@bootstrap.service
          pxcnode71#grep password /var/log/mysqld.log         
          pxcnode71#mysql -uroot -p".DzCBdzC*2?#"
          pxcnode71#alter user root@"localhost" identified by "123456";
          pxcnode71# grant reload,lock tables,replication client,process on *.* to sstuser@"localhost" identified by "123qqq...A"; 全量同步用户

          pxcnode72#systemctl start mysql
          pxcnode73#systemctl start mysql
* 测试配置
    #mysql -uroot -p"123456"
    mysql> show status like "%wsrep%"; 查看集群信息

    任意一台添加授权用户用于客户端登录  (注意:建表时,必须有主键字段primary key)
    73#grant all on *.* to lh@"%" identified by "123456";
    50#mysql -uroot -p123456 -h192.168.4.71

    集群功能:
     在任意一台服务器上添加访问数据的授权用户
     在客户端使用授权用户连接任意数据服务器都可以存储数据,且可以查看到同样的数据
     建表时,必须有主键字段primary key
  高可用测试:
    mysql> create table db10.a(id int primary key auto_increment,name char(50));
    mysql> insert into db10.a(name) values("tom") 
     停掉73服务,然后去72添加数据,在恢复73,数据也正常恢复.
    [root@pxcnode73 PXC]# systemctl stop mysql
    [root@pxcnode73 PXC]# ss -anptu | grep 3306
    [root@pxcnode73 PXC]# ss -anptu | grep 4567
    mysql> insert into db10.a(name) values("dc3")
    mysql> insert into db10.a(name) values("dc13")
    [root@pxcnode73 PXC]#tail -f /var/log/mysqld.log

二、存储引擎
    什么是Mysql存储引擎
       是mysql服务软件自带的,功能程序,处理表的处理器,不同的存储引擎有不同的功能和数据存储方式.

查看软件版本:mysql> show variables like "%version%";
查看存储引擎的命令:mysql> show engines;
建表指定存储引擎:
查看表存储引擎:mysql> show create table db5.t1;
修改表引擎:mysql> alter table db5.t1 engine=myisam;
常用存储引擎myisam特点:支持表锁,不支持事务,事务回滚,外键
常用存储引擎innodbde特点:支持行级锁定 支持事务,事务回滚,外键
如何决定使用那种存储引擎:
     select                     查多的适用myisam 比较节省系统硬件资源 读锁 支持并发
      insert/update/delete      写多的适合innodb 支持对单张表的并发写 写锁 

锁粒度:行级锁 表级锁
锁类型:读锁 写锁
查看当前锁:show status like "table_lock%";

事物:
事物回滚:
事物的特点(ACID):

行级锁:仅对被访问的行分别加锁
表级锁:对整张表加锁
查看当前锁状态:mysql> show status like "table_lock%";




事物:mysql连接到执行完exit退出是一个事物
事物回滚:操作过程中出现错误,可还原,没有commit提交的数据

事物日志文件:
ibdata1      未提交的
ib_logfile0  提交的
ib_logfile1  提交的

事物特性(ACID):(查看自动提交和关闭自动提交)
Atomic:原子性(要不成功要不失败)
Consistency:一致性
事物操作的前后,表中的记录没有变化
Isolation 隔离性
事物操作是相互隔离不受影响的,没有回车互相不知道
Durability:持久性
数据一旦提交,不可改变,永久改变表数据

查看自动提交:show variables like "autocommit";
关闭自动提交:set autocommit=off;
数据回滚到之前数据:rollback;
进行数据提交:commit;
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
####################################################################################################################################
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                              day11 搭建Redis数据库服务器   (50 51) 
一、部署redis服务器
      关系型数据库软件
      MySQL、MariaDB、Oracle 、DB2 、SQL Server
      非关系型软件(不仅是SQL)
      Memcached、Redis、MongoDB、CouchDB、NEo4j、FlockDB
    *源码包安装
    host50 redis-4.0.8]#yum -y install gcc
    host50 redis-4.0.8]#cd /root/
    host50 redis-4.0.8]#tar -xzvf redis-4.0.8.tar.gz
    host50 redis-4.0.8]#cd redis-4.0.8/
    make && make install
    * 配置运行服务运行参数
    [root@host50 redis-4.0.8]# ./utils/install_server.sh
       6379                                          端口号  
     /etc/redis/6379.conf                 主配置文件
     /var/lib/redis/6379                  数据库目录
     /usr/local/bin/redis-server          服务启动程序
     /usr/local/bin/redis-cli             命令连接命令
     /usr/log/redis_6379.log              日志文件

      默认是开启的开启状态:/etc/init.d/redis_6379 start
      开启查看状态#netstat -utnlp | grep :6379
      访问服务及基本操作命令:redis-cli 
     >ping              检测连接状态
     >set name bob      存数据设置1个key值
     >get bob           获取key值
     >mset x 1 y 1 z 3  存数据设置多个key值 
     >mget x y z name   查看多个key值
     >select 1          切换库编号0-15
     >keys *            显示所有变量名
     >keys ??           显示二个字符的key
     >exists y          检测key名是否存在
     >ttl x             查看key生存时间,-1永不过期
     >expire y 30       设置生存有效时间30s
     >type x            查看key类型(注:key的类型取决于我是怎么创建的key值)
     >lpush   ss        创建列表
     >move x 1          移动key值x到库1里
     >del x             删除指定的key值,删除变量x
     >flushdb           删除当前所在库的所有key
     >flushall          删除内存所有的key
     >save              保存所有key到硬盘
     >shutdown          停止服务并自动保存所有的key
   * 设置密码 IP地址 端口
     #vim /etc/redis/6379.conf
      requirepass 123456
      bind 192.168.4.50
      port 6350
      #redis-cli -h 192.168.4.50 -p 6350 -a 123456
      #/etc/init.d/redis_6379 stop
      #redis-cli -h 192.168.4.50 -p 6350 -a 123456 shutdown   必须这样关
      #/etc/init.d/redis_6379 start
      #redis-cli -h 192.168.4.50 -p 6350 -a 123456
      #vim /etc/init.d/redis_6379    修改第43行 
          $CLIEXEC -h 192.168.4.50 -p 6350 -a 123456 shutdown
      #/etc/init.d/redis_6379 start
      #/etc/init.d/redis_6379 stop             修改完配置文件之后才能继续脚本执行stop,要不然需要上面的-a 123456 shutdown

      #/var/run/redis_6379.pid  如果起不来,去这个目录把这个进程号删掉重启一下

   * 配置lnmp
   * 配置支持php支持的redis
     $#scp /linux-soft/03/redis/lnmp/php-redis-2.2.4.tar.gz root@192.168.4.51:/root
     host51#tar -xzvf php-redis-2.2.4.tar.gz
     host51#cd phpredis-2.2.4/
     host51#phpize
     host51#./configure --with-php-config=/usr/bin/php-config
     host51#make
     host51#make install
     host51#ls /usr/lib64/php/modules/
     host51#php -m | grep -i redis
  
   * 修改PHP的程序的主配置文件,加载redis模块 
     host51#vim /etc/php.ini
                728 extension_dir = "/usr/lib64/php/modules/"
                730 extension = "redis.so" 

   * 测试配置  (存取脚本都写在一起了)
     vim /usr/local/nginx/html/redis/php
<?php
$redis = new redis();
$redis->connect('192.168.4.50',6350);
$redis->auth("123456");
$redis->set('linux','redhat');
echo $redis->get("linux");
?>

curl http://192.168.4.51/set.php
                                                                                                                                                      
     
        
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
####################################################################################################################################
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                              day12 创建集群 分布式高可用集群 (50 57* 51 52 53 54 55 56)
redis集群是通过CRC16算法进行hash计算与16384取余计算进行分配服务器.管理主机是一个ruby脚本
高可用最少3个主            主服务器上有hash槽如0-5461 在管理主机创建集群的时候会给主服务器自动分配hasg槽.
1、创建集群
        1、在所有集群主机上运行redis服务(只往主上存数据)
        2、配置管理主机57
         [student@room9pc01 redis]$ scp redis-4.0.8.tar.gz root@192.168.4.57:/root/
         [student@room9pc01 redis]$ scp redis-3.2.1.gem root@192.168.4.57:/root/
         [root@host57 ~]#yum -y install ruby
         [root@host57 ~]#which gem
         [root@host57 ~]#gem install redis-3.2.1.gem
         [root@host57 ~]#mkdir /root/bin
         [root@host57 ~]#cp redis-trib.rb /root/bin
         [root@host57 ~]#redis-trib.rb help
         3、在所有主机上启用集群功能(51-56都要执行)
           [root@host51 ~]# redis-cli -h 192.168.4.51 -p 6351
                192.168.4.51:6351> cluster nodes    查看集群功能
           [root@host51 ~]# /etc/init.d/redis_6379 stop
           [root@host51 ~]# vim /etc/redis/6379.conf          开启集群功能
                               815 cluster-enabled yes 
                               823 cluster-config-file nodes-6379.conf
                               829 cluster-node-timeout 5000
                               :wq
           [root@host51 ~]#/etc/init.d/redis_6379 start
           [root@host51 ~]#cat /var/lib/redis/6379/nodes-6379.conf
           [root@host53 ~]# ss -nptul | grep redis-server 
         4、创建集群(57)
           [root@host57 ~]# redis-trib.rb create --replicas 1 192.168.4.51:6351 192.168.4.52:6352 192.168.4.53:6353 192.168.4.54:6354 192.168.4.55:6355 192.168.4.56:6356                                   创建集群
           [root@host57 ~]# redis-trib.rb info 192.168.4.51:6351      查看集群信息
           [root@host57 ~]# redis-trib.rb check 192.168.4.51:6351     查看集群主从信息包括hash槽

           [root@host51 ~]#cat /var/lib/redis/6379/nodes-6379.conf    查看集群节点信息
           [root@host51 ~]#redis-cli -h 192.168.4.51 -p 6351
           192.168.4.51:6351> cluster nodes                           查看集群节点信息
              
         5、排错
              数据必须清空  redis服务器没有启用集群功能
              每一台都需要删除nodes节点配置之后在重启redis服务
           [root@host51 ~]# redis-cli -h 192.168.4.51 -p 6351
           >flushall
           [root@host51 ~]rm -rf   /var/lib/redis/6379/nodes-6379.conf

         6、访问集群存/取数据
             
          [root@host50 ~]# redis-cli -c -h 192.168.4.56 -p 6356
          192.168.4.56:6356> set name lh
          -> Redirected to slot [5798] located at 192.168.4.52:6352
          OK
          192.168.4.52:6352> set xixi xixi
          -> Redirected to slot [15923] located at 192.168.4.53:6353
          OK
          192.168.4.53:6353> set haha haha
          -> Redirected to slot [3662] located at 192.168.4.51:6351
          OK

         7、集群工作原理
           获取变量名 用CRC16算法 做hash算法 把计算机的结果 与 16384做求模计算根据计算结果存储数据
         8、测试集群的高可用集群
               停止master主机的redis服务
            master后对应的slave自动被切换选举为master
               原master启动后会自动配置为当前master的slave           

2、管理集群
     2.1 向集群里添加新的redis服务器
          2.1.1 添加master角色服务器
                 1 克隆一台192.168.4.58
                 2 运行redis服务器并启用集群功能
                 3 在管理主机向机群添加master角色的redis服务器
                   [root@host57 ~]# redis-trib.rb add-node 192.168.4.58:6358 192.168.4.52:6352
                   [root@host57 ~]# redis-trib.rb info 192.168.4.51:6351
             
                 4 给添加的master角色
                   [root@host57 ~]# redis-trib.rb check 192.168.4.52:6352   先查看所有ID
                   [root@host57 ~]# redis-trib.rb reshard 192.168.4.52:6352
                   [root@host57 ~]# redis-trib.rb reshard 192.168.4.52:6352
                          How many slots do you want to move (from 1 to 16384)? 4096
                          What is the receiving node ID? e309029bea745faabd0bb003ce2d081609baf3ff
                          Source node #1:all
                          yes

          2.1.2 添加slave角色服务器
                 1 克隆一台192.168.4.59
                 2 运行redis服务器并启用集群功能
                 3 在管理主机向机群添加master角色的redis服务器
                [root@host57 ~]#redis-trib.rb add-node --slave 192.168.4.59:6359 192.168.4.51:6351
                [root@host57 ~]#redis-trib.rb check 192.168.4.52:6352
          2.1.3 删除slave角色服务器 前面是集群随便一个IP,后面跟的是slave移除主机的ID
                [root@host57 ~]#redis-trib.rb del-node 192.168.4.51:6351 3cfcd70086f02c032f7f974e2f3c9ab7e3abbffe
                [root@host57 ~]#redis-trib.rb check 192.168.4.52:6352

          2.1.4 删除master角色服务器先释放hash槽,在移除主机 前面是集群随便一个IP,后面跟的是master移除主机的ID
                [root@host57 ~]#redis-trib.rb reshard 192.168.4.51:6351
                [root@host57 ~]#redis-trib.rb check 192.168.4.52:6352
                [root@host57 ~]#redis-trib.rb info 192.168.4.52:6352
                [root@host57 ~]#redis-trib.rb del-node 192.168.4.51:6351 e309029bea745faabd0bb003ce2d081609baf3ff

          2.1.5 hash槽平均分配
                [root@host57 ~]#redis-trib.rb rebalance 192.168.4.51:6351
          2.1.6 把移除的主机添加进来
                先去59上清除记录的集群记录,然后清空记录并删除所有数据
                [root@host59 redis-4.0.8]# redis-cli -h 192.168.4.59 -p 6359
                192.168.4.59:6359> cluster reset
                192.168.4.59:6359> flushall
                   去管理57添加集群 
                [root@host57 redis-4.0.8]#[root@host57 ~]# redis-trib.rb add-node --slave --master-id 511a7f7845dbf4df25086b0b19fcb7dfd496925e 192.168.4.59:6359 192.168.4.52:6352
                [root@host57 ~]# redis-trib.rb info 192.168.4.51:6351

          2.1.7 把集群中的机器恢复为独立的redis服务器 51~58
                1 删除数据                 
                2 停止服务
                3 禁用集群功能
                4 删除数据库下的所有文件


                 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
####################################################################################################################################
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                              day13 NoSQL的Redis主从复制持久化   (50 51 52 53 54 55) 
有了集群,为什么还会用主从,都为数据备份高可用技术,集群最少需要6台服务器,主从2台就够了,数据少的情况用主从结构即可,不需要搭建集群.
redis的主从同步过程:从向主发送sync命令,主收到把所有数据存放到后台存盘传给从slave,从收到之后把数据加载到内存当中进行完全备份,会把自己的数据覆盖,如果主新产生数据,会依次传给从,进行的是增量备份.
1、Redis主从复制只有数据备份,没有高可用
        临时主从:
               host51#不需要在主配置,默认都是主
               host52#redis-cli -h 192.168.4.52 -p 6352
               192.168.4.52:6352> slaveof 192.168.4.51 6351
               192.168.4.52:6352> info replication  查看复制信息
               192.168.4.52:6352> slaveof no one 临时取消从,但是数据同步过去的就已经同步
 
         永久主从配置:host52#vim /etc/redis/6379.conf 
                    282 slaveof 192.168.4.51 6351
                    52#/etc/init.d/redis_6379 stop
                    52#/etc/init.d/redis_6379 start
                   带验证的主从,就是主服务器设置了密码:
                   主服务器设置密码:host51#vim /etc/redis/6379.conf
                              501 requirepass 123456 
                   从服务器指定连接密码:host52#vim /etc/redis/6379.conf
                              289 masteruth 123456
         一主多从:就是在选一台与上述永久配置的从服务器52配置一样.
         主从从:与上配置一致
         注意:默认情况当主宕机之后,从服务器不会自动升级主服务器,需要和别的哨兵服务一起实现.
2、哨兵服务
   什么是哨兵服务: 
             监视master服务器
             发现master宕机后,将从服务器升级为主服务器
             主配置文件sentinel.conf
             模板文件:redis-4.0.8/sentinel.conf

   需要装redis服务,不需要启动redis配置直接编辑配置文件就行
           修改配置文件:[root@host57 redis-4.0.8]# vim /etc/sentinel.conf
                    bind 0.0.0.0
                    port 26379 
                    sentinel monitor redis54 192.168.4.54 6354 1
           启动哨兵服务:[root@host57 redis-4.0.8]# redis-sentinel /etc/sentinel.conf

3、数据持久化  数据永久存储的方式(RDB和AOF)
       RDB:记录数据的文件
            默认的存储数据在/var/lib/redis/6379/dump.rdb   默认15分钟1个key 5分钟10个key 1分钟10000个key会自动保存
            数据恢复:scp dump.rdb root@192.168.4.59:/var/lib/redis/6379/dump.rdb
                 59先关闭在删除在scp再重启即可
           优点:
               
           缺点:
               意外宕机时,丢失最后一次持久化的所有数据,是硬件坏掉,不是shutdown,不会自动保存.
       AOF:记录命令的文件(一般和RDB一起用,RDB是存数据,AOF是记录操作,如果只有AOF,服务重启之后查看数据就是空的,没有重启,数据在内存上有)
            优点:灵活设置持久化方式体现在三种存盘方式always everysex no
                 出现意外宕机,仅可能丢失1s的数据
            缺点:
                 持久化的体积通常会大于RDB,因为是把每个操作记录到.aof文件
                 执行sync策略时的速度会比RDB方式慢 主从
             设置和永久配置aof文件
             192.168.4.50:6350> config set appendonly yes
             192.168.4.50:6350> config rewrite
             [root@host50]#ls /var/lib/redis/6379/
             恢复数据与dump.rdb一样,[root@host50 6379]#scp appendonly.aof root@192.168.4.59:/var/lib/redis/6379/
             存盘方式有三种:always与磁盘时刻记录   everysex 与磁盘每秒记录一次 no 不执行磁盘同步
             如果aof有所损坏,可以配置进行修复再启动[root@host50 6379]#  redis-check-aof --fix appendonly.aof
4、Redis类型 
* set字符类型
set name a ex 10  有效期10s px毫秒 NX不强制赋值不加就是强制赋值  什么也不加就是永不过期
ttl a 查看生存时间
* setrange 从偏移量开始复写特定的变量 (从左往右0开始计数)
192.168.4.50:6350> set first "hello world"
192.168.4.50:6350> setrange first 6 "Redis"
192.168.4.50:6350> get first
"hello Redis"
* append 向已有的变量追加
* setbit 
1G=1024M
1M=1024K
1k=1024B yte
1字节=8位
* bitcount key
* decr key      key值自减1
* decrby key decrement  key值减多少   
* get key 查看key值
* getrange key start end 获取范围内的子字符0开始 -1结束
* incr key  将key的值加1,没有默认0开始
* incrby key  4(increment) 将key的值加4
* incrbyfloat key increment 将浮点数增加多少
* mget key
* mset key value
列表:lpush  字符队列,先进后出,可以有多个值
* lpush key value value  定义列表在插入是插入队头
* lrange key start stop初开始位置读取结束位置----lrange list 0 -1  输出查看
* lpop key 删除表头第一个
* llen key 返回列别长度
* lindex key 0 输出key第1个值
* lset key index value 将key的第几个值修改为value
* rpush key value 插入队尾key值
* rpop key       删除队尾
Hash表:一个hash表有多列,每列对应一个值
* hset key field value(hset bob age 19;hset bob sex girl)将hash表的age列设置为19
* hget bob age 获取hash的age列的值
* hmset bob tel 88888 qq 123456 设置hash表的多列值
* hmget tel qq                  获取hash表多列的值
* hkeys bob                     获取bob的列名
* hvals bob                     获取bob列的所有值
* hgetall bob                   获取列名和值
* hdel bob tel                  删除hash表的tel列  删除列
